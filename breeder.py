from  __future__ import division

from gene import Gene
from geneCreator import GeneCreator
from manage_images import ManageImages
from model_factory import ModelFactory
from gene import Gene
from datas import Datas
from geneCreator import GeneCreator
from import_all import *

class Breeder:

	#from an old generation create a new n-sized generation with lots of genes belonging to the
	#following groups:
	#1) some of the good old ones
	#2) some generated by parts of the old good ones
	#3) some that are new random generated genes
	def getNewGeneration( self, old, n):
		geneCreator = GeneCreator()
		newGeneration = list()
		strongestN = 1
		reproducibleN = math.ceil(n/2)
		randomAdds = n - strongestN - reproducibleN
		#1)
		goods = self.takeGoods( old , strongestN )
		#2)
		reproducible = self.takeGoods(old, reproducibleN )
		
		#I want to maintain old goods in my genetic pools
		for i in range( 0, len(goods) ):
			newGeneration.append(goods[i])
			#print( "old good" )
		
		#I want some sons generated by goods
		for i in range( 0 , (n - strongestN - randomAdds ) ):
			son = self.getSon( reproducible )
			newGeneration.append(son)
			#print("sons")

		#I want also some randoms new borns
		for i in range( 0, randomAdds ):
			newGeneration.append( geneCreator.randomCreate() )
			#print("random")

		return newGeneration

	# simplified: each feature is takes by a single random chosen parent
	# (and one is cabled)
	def getSon( self, parents ):
		dri = random.randint(0, (len(parents) - 1 ) )
		dr = parents[dri].dropout
		l1i = random.randint(0, (len(parents) - 1 ) )
		l1 = parents[l1i].l1
		son = Gene( 0.001,	dr, l1 )
		
		return son	

	#for each gene, use it to create a model, train the model, evalue it.
	def run(self, generations, datas):
		runnedGeneration = list()

		for i in range( 0 , len(generations)):
			
			thisGene = generations[i]
			model_factory = ModelFactory()
			model = model_factory.getModel( thisGene )
			
			result = model_factory.run( datas, model, 0 )
			thisGene.setFitnessLevel( result ) 
			'''
			thisGene.level = random.random()
			print("\n\nrunning gene:")
			thisGene.toStr()
			'''

			runnedGeneration.append(thisGene)

		return runnedGeneration	

	#the first generation is completely random
	def getFirstGeneration( self, n ):
		genes = list()
		creator = GeneCreator()
		for i in range( 0 , n):
			g = creator.randomCreate()
			genes.append(g)
		return genes

	def orderGenes( self , genes ):
		result = []
		genesSet = set(genes)
		genes = list( genesSet ) # no doubles!
		#for i in range( 0, len(genes) ):
		#	print( "before: " + str(genes[i].level) )		
		
		result = sorted(genes, key=lambda x: x.level, reverse=False)
		#for i in range( 0, len(result) ):
		#	print( "after: " + str(result[i].level) )		
		
		return result

	def takeGoods( self, genes, n ):
		goods = []

		for i in range(0, len(genes) ):
			g = genes[i]
			goods.append(g)
			goods = self.orderGenes( goods )
			if( len( goods ) > n):
				goods = goods[ 0 : n ]

		#for i in range( 0, len(goods) ):
		#	print( "goods: " + str( goods[i].level ) )		
		return goods		    

	
	def takeBest( self, genes ):
		return self.takeGoods( genes, 1 )[0]
		'''
		minLevel = float("inf") #level of error
		bestGene = None

		for i in range(0, len(genes) ):
			g = genes[i]
			#print( "i:" + str(i) + ";  " + str(g.level) + " vs " + str(minLevel) )
			if( g.level < minLevel ):
				bestGene = g
				minLevel = g.level

		return bestGene		
		'''

